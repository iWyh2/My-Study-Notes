# 《大话数据结构》

# 1. 线性表

【特性】

* 零个或多个数据元素的有限序列（有顺序）
* 线性表元素的个数n为线性表的长度



【定义】

```apl
ADT List(线性表)
Data
	线性表的数据对象集合为{a1,a2,a3,...,an}，每个元素的类型均为DataType。其中，除第一个元素a1外，每一个元素有且只有一个直接前驱元素，除了最后一个元素an外，每一个元素有且只有一个直接后继元素。数据元素之间的关系是一对一的关系
Operation
	InitList(*L) := 初始化操作，建立一个空的线性表L
	ListEmpty(L) := 若线性表为空，返回true，否则返回false
	ClearList(*L) := 将线性表清空
	GetElem(L,i,*e) := 将线性表L中的第i个位置元素值返回给e
	LocateElem(L,e) := 在线性表L中查找与给定值e相等的元素，如果查找成功，返回该元素在表中序号表示成功；否则，返回0表示失败
	ListInsert(*L,i,e) := 在线性表L中的第i个位置插入新元素e
	ListDelete(*L,i,*e) := 删除线性表L中第i个位置元素，并用e返回其值
	ListLength(L) := 返回线性表L的元素个数
endADT
```

## 1.1 线性表的线性存储结构

【特性】

* 用连续地址的存储单元存储线性表元素
* 一维数组即可实现

* 地址计算方法（LOC函数）：LOC(ai) = LOC(a1) + (i - 1) * c（每个元素占据c个存储单元）
* 存取时间性能为O(1)，为随机存取结构

* 线性表长度要小于数组长度



【性能优缺点】

优点：

* 插入到最后一个元素：O(1)
* 删除最后一个元素：O(1)
* 读取任意位置元素：O(1)
* 快速存取

缺点：

* 插入到第一个位置：O(n)
* 删除第一个位置元素：O(n)
* 插入第i个和删除第i个平均为：O(n)
* 插入和删除需要移动大量元素

## 1.2 线性表的链式存储结构

### 1.2.1 单链表

【特性】

* 地址并不连续的存储单元存储元素
* 元素由节点Node存储，节点由指针域和数据域组成
* 指针域只指向后继



【性能优缺点】

时间性能

优点：

* 插入和删除：O(1)

缺点：

* 查找：O(n)

空间性能：单链表无需预分配存储空间，元素个数不受限制



【单链表与顺序存储】

频繁查找，很少插入删除：顺序存储

频繁插入删除：单链表

元素变化较大且不知数量：单链表

提前知道线性表长度：顺序存储

### 1.2.2 静态链表

【特性】

* 用数组替代指针来描述单链表
* 数组每个元素都有两个数据域：data 和 cur
* data是存放数据用。cur为存放该元素的后继在数组中的下标位置，也叫游标
* 数组第一个和最后一个位置不存数据，作为特殊元素
* 未被使用的数组元素为备用链表
* 数组第一个元素，cur存放备用链表的第一个结点的下标位置，备用链表的头指针
* 数组的最后一个元素，cur存放第一个有数值的元素的下标位置，相当于头结点
* 线性表的最后一个有值元素的下一位置为空，所以最后一个有值元素的cur存放0



【性能优缺点】

优点

* 插入删除：O(1)

缺点

* 平均查找：O(n)（单链表的特性）

* 失去了顺序存储结构的随机存取

### 1.2.3 循环链表

【特性】

* 单链表终结点指针指向头结点，成为单循环链表
* 从一个节点出发访问到链表的全部节点
* 判断遍历的结束条件为：下一节点不为头结点



【性能优缺点】

优点

* 查找头尾结点：O(1)

### 1.2.4 双向链表

【特性】

* 每个节点都有前驱和后继，两个指针域
* 许多操作与单链表相同，只涉及一个方向
* 也可以是循环链表



【性能优缺点】

优点

* 插入和删除：O(1)
* 查找头尾结点：O(1)

缺点：

* 平均查找：O(n)

------



# 2. 栈

【特性】

* 仅在表尾进行插入和删除操作的**线性表**
* 后进先出（Last In First Out）
* 允许插入和删除的一端为栈顶（top），另一端为栈底（bottom）
* 栈顶就是表尾
* 最先进入的只能在栈底



【定义】

```apl
ADT Stack(栈)
Data
	同线性表。元素具有相同类型，相邻元素具有前驱和后继关系
Operation
	InitStack(*S) := 初始化操作，建立一个空栈S
	DestroyStack(*S) := 若栈存在就销毁
	ClearStack(*S) := 将栈清空
	StackEmpty(S) := 若栈为空，返回true，否则返回false
	GetTop(S,*e) := 若栈存在且非空，用e返回S的栈顶元素
	Push(*S,e) := 若栈S存在，插入新元素e到栈S中并成为栈顶元素
	Pop(*S,*e) := 删除栈S中栈顶元素，并用e返回其值
	StackLength(S) := 返回栈S的元素个数
endADT
```

## 2.1 栈的顺序存储结构

【特性】

* 为线性表的顺序存储的简化
* 下标为0的一端作为栈底
* top指示栈顶元素在数组中的位置
* 空栈为：top = -1



【性能优缺点】

优点

* 出栈入栈均为：O(1)

缺点

* 顺序栈需要事先确定一个固定的长度，会有浪费内存空间的情况

## 2.2 栈的链式存储结构

【特性】

* 栈顶放在单链表的头部
* 不需要头结点
* 不存在栈满的情况
* 空栈：top = NULL



【性能优缺点】

优点

* 出栈入栈均为：O(1)

缺点

* 链栈每个元素有指针域，有额外的内存开销



【对比】

* 元素变化不可预料，有时很小，有时很大，用链栈
* 变化在可控范围内用顺序栈



【栈的应用】

* 递归（斐波那契数列）
* 四则远算表达式（后缀表达式）

------



# 3. 队列

【特性】

* 只允许在一端进行插入操作，在另一端进行删除操作的**线性表**
* 先进先出（First In First Out）
* 插入的一端为队尾，删除的一端为队头



【定义】

```apl
ADT Queue(队列)
Data
	同线性表。元素具有相同类型，相邻元素具有前驱和后继关系
Operation
	InitQueue(*Q) := 初始化操作，建立一个空队列Q
	DestroyQueue(*Q) := 若队列存在就销毁
	ClearQueue(*Q) := 将队列清空
	QueueEmpty(Q) := 若队列为空，返回true，否则返回false
	GetHead(Q,*e) := 若队列存在且非空，用e返回队列Q的队头元素
	EnQueue(*Q,e) := 若队列存在，插入新元素e到队列Q中并成为队尾元素
	DeQueue(*Q,*e) := 删除队列中队头元素，并用e返回其值
	QueueLength(Q) := 返回队列的元素个数
endADT
```

## 3.1 队列的顺序存储结构

【特性】

* 入队列操作不需要移动元素，在队尾追加一个元素
* 出队列操作需要所有的元素向前移动
* front指针指向队头元素，rear指针指向队尾元素的下一个位置
* 空队列：front == rear



【性能优缺点】

优点

* 入列：O(1)

缺点

* 出列：O(n)
* 会有假溢出现象，浪费内存

### 3.1.1 循环队列

【特性】

* 头尾相接
* 空队列：front == rear
* 满队列：(rear + 1) % QueueSize == front（保留一个元素位置为队列满）
* 队列长度：（rear - front + QueueSize ）% QueueSize
* 数组可能会溢出



【性能优缺点】

优点

* 入列：O(1)
* 出队：O(1)

缺点

* 必须有固定的长度，会有内存浪费

## 3.2 队列的链式存储结构

【特性】

* 只能尾进头出
* 头指针指向头结点
* 空队列：front和rear都指向头结点
* 入链队列，无需判断队满
* 出链队列，头结点的后继结点出队



【性能优缺点】

优点

* 入列：O(1)
* 出队：O(1)

缺点

* 每次申请和释放结点会有时间开销
* 指针域会有内存上的额外开销



【链队列和循环队列对比】

* 确定队列最大长度用循环队列
* 无法估计队列长度用链队列

------



# 4. 串



------



# 5. 树

【特性】

* 一对多
* 只有一个根结点
* 子树个数没有限制，且互不相交
* 结点拥有的子树数称为**结点的度**（Degree）
* 树内各结点的度的最大值为**树的度**
* 度为0的结点为**叶结点**（也叫终端节点），度不为0的结点也叫分支结点
* 结点关系：孩子（Child），双亲（Parent），兄弟（Sibling）
* **结点的层次**（Level）：从根结点开始的层数，根结点在第一层；同一层的结点为堂兄弟
* 树中结点的最大层次称为**树的深度**/**高度**（Depth）
* 有序树：各子树从左至右有次序，不能互换；反之为无序数
* 森林：互不相交的树的集合；每个结点的子树的集合就是森林



【定义】

```apl
ADT Tree(树)
Data
	树由一个根结点和若干子树构成。树中结点具有相同数据类型及层次关系
Operation
	InitTree(*T) := 构造空树T
	DestroyTree(*T) := 销毁树T
	CreateTree(*T,definition) := 按definition给出的树的定义构造树
	ClearTree(*T) := 将树T清空
	TreeEmpty(T) := 若树T为空，返回true，否则返回false
	TreeDepth(T) := 返回树的深度
	Root(T) := 返回树的根结点
	Value(T,cur_e) := cur_e是树的一个结点，返回此结点的值
	Assign(T,cur_e,value) := 给树的结点cur_e赋值为value
	Parent(T,cur_e) := 若cur_e是树的非根结点，则返回双亲结点，否则返回空
	LeftChild(T,cur_e) := 若cur_e是树的非叶结点，则返回cur_e的最左孩子，否则返回空
	RightSibling(T,cur_e) := 若cur_e有右兄弟，则返回cur_e的右兄弟，否则返回空
	InsertChild(*T,*p,i,c) := p指向树中某个结点，i为所指结点p的度加1，c为非空树与T不相交，操作为插入c为树T中p指向结点的第i棵子树
	DeleteChild(*T,*p,i) := p指向树中某个结点，i为所指结点p的度，操作为删除T中p所指向的结点的第i棵子树
endADT
```



【树的存储结构】

1. 双亲表示法

   除了根结点外，其余每个结点不一定有孩子，但一定有且仅有一个双亲

   **以连续空间存储**树的结点

   ①树的结点包含：data数据域，parent指针域（指向双亲）

   * 约定根结点的位置域为-1
   * 无法得知孩子结点是什么，需要遍历完才得知

   ②树的结点包含：data数据域，parent指针域，firstchild指针域（指向最左孩子）

   * 约定没有孩子则为-1
   * 无法得知兄弟节点

   ③树的结点包含：data数据域，parent指针域，firstchild指针域，rightsib指针域（指向右兄弟）

   * 约定没有右兄弟为-1

2. 孩子表示法

   树中每个结点可能有多棵子树

   以**多重链表**表示

   ①树的结点有多个指针域，指针域个数为树的度：data数据域，child1，child2...各指针域

   * 各结点度相差很大时会浪费空间

   ②树的结点有多个指针域，指针域个数为该结点的度，额外增添一个度域：data数据域，degree度域，child1，child2...各指针域

   * 各结点结构不同，要额外维护度域的值，运算和维护耗费大

   以**数组+链表**表示

   将每个结点的孩子以单链表存储，各链表头指针又组成一个线性表

   孩子链表的孩子结点：child数据域，next指针域（指向下一个孩子）

   表头数组的表头结点：data数据域（结点的数据），firstchild指针域（存储结点的孩子链表的头指针）

   要得知结点的双亲，需要在表头数组中额外添加一个parent指针域（存储双亲下标，根结点为-1）

3. 孩子兄弟表示法

   寻找结点的第一个孩子和右兄弟

   以**链表**表示

   结点包含：data数据域，firstchild指针域，rightsib指针域

   * 方便查找某结点的某个孩子
   * 可以额外增添parent指针域查询存储双亲
   * **将一棵复杂的树变为了一棵二叉树**

## 5.1 二叉树

Binary Tree

【特点】

* 每个结点最多两棵子树（二叉树不存在度大于2的结点）
* 左子树和右子树有次序，无法颠倒
* 即使树的某结点只有一颗子树，也要区分是左子树还是右子树（也许是同一棵树，但是是不同的二叉树）



【二叉树的五种形态】

* 空树
* 只有一个根结点
* 根结点只有左树
* 根结点只有右树
* 根结点有左右子树



【二叉树的特殊形态】

* 斜树
  * 所有结点只有左子树或右子树，分别叫左斜树和右斜树
  * 每一层只有一个结点
  * 结点个数 = 树的深度
  * **线性表为特殊的树结构**，为斜树

* 满二叉树
  * 所有分支结点都有左右子树
  * 所有叶子结点都在同一层
  * 最后一层必定是叶子结点
  * 非叶子结点的度一定为2
  * 同样深度的二叉树，满二叉树结点个数最多，叶子结点最多

* 完全二叉树
  * 所有结点顺序位置（从1到n按层序编号）与相同深度的满二叉树的结点位置一一对应
  * 满二叉树一定是完全二叉树；完全二叉树不一定是满二叉树
  * 叶子结点一定只能在最下两层位置
  * 最后一层叶子结点靠左连续集中
  * 倒数第二层如果有叶子节点，一定靠右连续集中
  * 结点度为1，只能有左孩子
  * 同样结点数的二叉树，完全二叉树深度最小



【性质】

1. 

## 5.2 线索二叉树

## 5.3 赫夫曼树

## 5.4 二叉排序树

## 5.5 平衡二叉树

## 5.6 2-3树

## 5.7 2-3-4树

## 5.8 B树

## 5.9 B+树

------



# 6. 图



------

