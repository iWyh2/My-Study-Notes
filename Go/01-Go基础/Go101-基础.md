# Go - [基础篇]

## Go官方工具链

介绍如何配置Go开发环境和如何使用Go官方工具链中提供的`go`命令

### 安装Go官方工具

[Go官方网站](https://go.dev/doc/install)下载Go官方工具链 :)

> 为了从任意目录运行Go官方工具链中工具命令（通过`go`命令）， Go官方工具链安装目录下的`bin`子目录路径必须配置在`PATH`环境变量中

Go官方工具链近来的版本均支持一个称为Go模块（Go modules）的特性，用来管理项目依赖（更多请了解[go mod说明](./go mod说明.md)）

> 从版本1.16开始被默认支持Go mod

了解环境变量：`GOPATH`

此环境变量的默认值为当前用户的HOME目录下的名为`go`文件夹对应的目录路径。 `GOPATH`环境变量可以被手动地配置多个路径。 以后，当`GOPATH`文件夹被提及的时候，它表示`GOPATH`环境变量中的第一个路径对应的文件夹

* `GOPATH`文件夹中的`pkg`子文件夹用来缓存被本地项目所依赖的Go模块（一个Go模块为若干Go库包的集合）的版本

了解环境变量：`GOBIN`

此环境变量用来指定`go install`子命令产生的Go应用程序二进制可执行文件应该存储在何处。 它的默认值为`GOPATH`文件夹中的`bin`子目录所对应的目录路径。 `GOBIN`路径需配置在`PATH`环境变量中，以便从任意目录运行这些Go应用程序

### 运行一个Go程序

最简单的一个Go程序

```go
package main

func main() {
}
```

> 在此程序中，单词`package`和`func`是两个关键字。 两个`main`是两个标识符
>
> 此程序的第一行指定了当前源代码文件所处的包的包名（此处为`main`）。 第二行是一个空行，用来增强可读性。 第三和第四行声明了一个名为`main`的函数。 此函数为程序的入口函数

Go官方工具链工具要求所有的Go源代码文件必须以`.go`后缀结尾。

假设上面展示的最简单的Go程序存放在一个名叫`simplest-go-program.go`的文件中

打开一个终端（控制台）并进入上述源文件所在的目录，然后运行

```bash
go run simplest-go-program.go
```

如果一个程序的`main`包中有若干Go源代码文件，我们也可以使用下面的命令运行此程序

```bash
go run .
```

注：

* `go run`子命令并不推荐在正式的大项目中使用

* `go run`子命令只是一种方便的方式来运行简单的Go程序
* 对于正式的项目，最好使用`go build`或者`go install`子命令构建可执行程序文件来运行Go程序

支持Go模块特性的Go项目的**根目录下**需要一个`go.mod`文件。此文件可以使用`go mod init`子命令来生成

名称以`_`和`.`开头的源代码文件将被Go官方工具链工具忽略掉

### 更多go子命令

`go run`、`go build`和`go install`构建可执行程序文件来运行Go程序，只会输出代码语法错误

`go vet`子命令可以用来检查可能的代码逻辑错误（即警告）

`go fmt`子命令用同一种代码风格格式化Go代码

`go test`子命令运行单元和基准测试用例

`go doc`子命令（在终端中）查看Go代码库包的文档

让你的Go项目支持Go模块特性来简化依赖管理：

* `go mod init example.com/myproject`命令可以用来在当前目录中生成一个`go.mod`文件。 当前目录将被视为一个名为`example.com/myproject`的模块（即当前项目）的**根目录**。 此`go.mod`文件将被用来记录当前项目需要的依赖模块和版本信息。 我们可以手动编辑或者使用`go`子命令来修改此文件
* `go mod tidy`命令用来通过扫描当前项目中的所有代码来**添加**未被记录的依赖至`go.mod`文件或从`go.mod`文件中**删除**不再被使用的依赖
* `go get`命令用拉添加、升级、降级或者删除单个依赖

从Go官方工具链1.16版本开始，我们可以运行`go install example.com/program@latest`来安装一个第三方Go程序的最新版本（至`GOBIN`目录）

`go help aSubCommand`来查看一个子命令`aSubCommand`的帮助信息

`go`命令将会列出所有支持的`go`子命令

更多go命令请在[go命令官网]((https://golang.google.cn/cmd/go/))查看 :)

### 查看Go标准库文档

请查看Go官方文档库：[Standard library - Go Packages](https://pkg.go.dev/std) :)

------



## 程序源代码基本元素介绍

将介绍编程中常用的代码元素，并展示一份简单的Go程序代码

### 编程和程序代码元素

编程可以看作是以各种方式控制和组合计算机运行中的各种操作，以达到各种各样的目的

一个操作可能从一个硬件设备读取、或者向一个硬件设备写入一些数据，从而完成一个特定的任务

对于现代计算机来说，最基本的操作是底层计算机指令，比如CPU和GPU指令

直接操控底层计算机指令进行编程是非常繁琐和容易出错的

高级编程语言通过对底层指令进行一些封装和对数据进行一些抽象，从而使得编程变得直观和易于理解

一个操作通常是通过**函数**（function）调用或者使用**操作符**（operator）运算来完成的

数据通常被抽象为各种**类型**（type）和**值**（value）。 一个类型可以看作是值的模板。一个值可以看作是某个类型的实例

 一些在编码阶段可确定的值可以用它们的**字面形式**（literal，即字面量）来表示，其它的值一般使用**变量**（variable）和**（具名）常量**（named constant）来表示

具名的函数、具名的值（包括变量和具名常量）、以及定义类型和类型别名将被统称为**代码要素**。 代码要素名必须为**[标识符（identifier）](#关键字和标识符)**。

高级编程语言代码将被编译器或者解释器转换为底层机器码进行执行。 为了帮助编译器和解释器解析高级语言代码，一些单词将被用做**[关键字（keyword）](#关键字和标识符)**。 这些单词不能被当做标识符使用

很多现代高级语言使用**包**（package）来组织代码。 一个包必须**引入**（import）另一个包才能使用另一个包中的公有（导出的）代码要素。 包名和包的引入名也都必须是标识符

和很多其流行语言一样，Go使用`//`来起始一个行注释，使用一个`/*`和`*/`对来包裹一个块注释

### 一个简单的Go示例程序

让我们来看一个简短的Go示例程序

```go
package main // 指定当前源文件所在的包名

import "math/rand" // 引入一个标准库包

const MaxRand = 16 // 声明一个具名整型常量

// 一个函数声明
/*
 StatRandomNumbers生成一些不大于MaxRand的非负
 随机整数，并统计和返回小于和大于MaxRand/2的随机数
 个数。输入参数numRands指定了要生成的随机数的总数。
*/
func StatRandomNumbers(numRands int) (int, int) {
	// 声明了两个变量（类型都为int，初始值都为0）
	var a, b int
	// 一个for循环代码块
	for i := 0; i < numRands; i++ {
		// 一个if-else条件控制代码块
		if rand.Intn(MaxRand) < MaxRand/2 {
			a = a + 1
		} else {
			b++ // 等价于：b = b + 1
		}
	}
	return a, b // 此函数返回两个结果
}

// main函数，或主函数，是一个程序的入口函数。
func main() {
	var num = 100
	// 调用上面声明的StatRandomNumbers函数，
	// 并将结果赋给使用短声明语句声明的两个变量。
	x, y := StatRandomNumbers(num)
	// 调用两个内置函数（print和println）。
	print("Result: ", x, " + ", y, " = ", num, "? ")
	println(x+y == num)
}
```

将上面的程序代码存盘到一个名为`basic-code-element-demo.go` 的文件中并使用下列命令运行此程序：

```bash
$ go run basic-code-element-demo.go
Result: 46 + 54 = 100? true
```

在上面的示例程序中，单词`package`、`import`、`const`、`func`、`var`、`for`、`if`、`else`和`return`均为关键字。 其它大多数单词均为标识符

四个`int`（一个在第*15*行，另三个在第*13*行） 表示内置基本类型`int`。int类型是Go中的内置基本整数类型之一。 

第*5*行中的`16`、第*17*行中的`0`、 第*20*行中的`1`以及第*30*行的`100`均为整型字面量。 

第*35*行的`"Result: "`是一个字符串字面量

第*20*行是一个赋值语句。

第*5*行声明了一个具名常量，叫做`MaxRand`。 

第*15*行和第*30*行使用标准变量声明语句声明了三个变量。 

第*17*行的变量`i`以及第*33*行的变量`x`和`y`是使用变量短声明语句声明的。 

变量`a`和`b`在声明的时候被指定为`int`类型。 编译器会自动推导出变量`i`、`num`、`x`和`y`的类型均为`int`类型，因为它们的初始值都是整型字面量表示的

上面的示例程序中使用了很多操作符，比如第*17*和*19*行的小于比较符`<`，第*36*行的等于比较符`==`，还有第*20*和*36*行的加法运算符`+`。 第*35*行中的`+`不是一个运算符，它是一个字符串字面量中的一个字符。 一个使用操作符的操作中涉及到的值称为操作值（有时也可称为运算数）

第*35*和*36*行调用了两个内置函数`print`和`println`。 从第*13*行到第*26*行声明的函数`StatRandomNumbers`在第*33*行被调用。 第*19*行也调用了一个函数 `Intn`。 这个函数声明在`math/rand`标准库包中

第*1*行指定了当前源文件所处的包的名称。 一个Go程序的主函数（`main`函数）必须被声明在一个名称为`main`的包中。 第*3*行引入了`math/rand`标准库包，并以`rand`做为引入名。 在这个包中声明的`Intn`函数将在第*19*行被调用

此处列出了所有的简单语句类型。 在Go代码中，各种流程控制代码块中的某些部分必须为简单语句，某些部分必须为表达式

`StatRandomNumbers`函数的声明体中使用了两个流程控制代码块。 其中一个是`for`循环代码块，它内嵌了另外一个代码块。 另外一个代码块是一个`if-else`条件控制代码块

### 代码断行

像很多其它流行编程语言一样，Go也使用一对大括号`{` and `}`来形成一个显式代码块

但是在Go代码中，编码样式风格有一些限制。比如，很多左大括号`{`不能被放到下一行

我们最好避免将左大括号放在下一行。 或者说，每行的非空起始字符不能是左大括号

------



## 关键字和标识符

将介绍Go中的关键字和标识符

### 关键字

关键字是一些特殊的用来帮助编译器理解和解析源代码的单词

截至目前（Go 1.20），Go中共有25个关键字

```go
break     default      func    interface  select
case      defer        go      map        struct
chan      else         goto    package    switch
const     fallthrough  if      range      type
continue  for          import  return     var
```

这些关键字可以分为四组：

- `const`、`func`、`import`、`package`、`type`和`var`用来声明各种代码元素。
- `chan`、`interface`、`map`和`struct`用做 一些组合类型的字面表示中。
- `break`、`case`、`continue`、`default`、 `else`、`fallthrough`、`for`、 `goto`、`if`、`range`、 `return`、`select`和`switch`用在流程控制语句中。 详见[基本流程控制语法](#)。
- `defer`和`go`也可以看作是流程控制关键字， 但它们有一些特殊的作用。详见[协程和延迟函数调用](#)。

### 标识符

一个标识符是一个以Unicode字母或者`_`开头并且完全由Unicode字母和Unicode数字组成的单词

注意：**关键字不能被用做标识符**

标识符`_`是一个特殊字符，它叫做**空标识符**

所有的类型名、变量名、常量名、跳转标签、包名和包的引入名都必须是标识符

一个由Unicode大写字母开头的标识符称为**导出标识符**。 这里**导出**可以被理解为**公开**（public）

其它（即非Unicode大写字母开头的）标识符称为非导出标识符。 ***非导出***可以被理解为**私有**（private）

下面是一些合法的导出标识符：

```go
Player_9
DoSomething
VERSION
Ĝo
Π
```

下面是一些合法的未导出标识符：

```go
_
_status
memStat
book
π
一个类型
변수
エラー
```

下面这些不能被用做标识符：

```go
// Unicode数字开头
123
3apples

// 含有不符合要求的Unicode字符
a.b
*ptr
$name
a@b.c

// 这两个是关键字
type
range
```

------



## 基本类型和它们的字面量表示

类型（type）可以被看作是值（value）的模板，值可以被看作是类型的实例。将介绍内置（或称为预声明的）基本类型和它们字面量的表示形式。不介绍组合类型。

### 基本内置类型

Go支持如下内置基本类型：

- 一种内置布尔类型：`bool`。
- 11种内置整数类型：`int8`、`uint8`、`int16`、`uint16`、`int32`、`uint32`、`int64`、`uint64`、`int`、`uint`和`uintptr`。
- 两种内置浮点数类型：`float32`和`float64`。
- 两种内置复数类型：`complex64`和`complex128`。
- 一种内置字符串类型：`string`。

内置类型也称为预声明类型

这17种内置基本类型（type）各自属于一种Go中的类型种类（kind）。 尽管所有的内置基本类型的名称都是[非导出标识符](#identifier)， 我们可以不用引入任何代码包而直接使用这些类型

除了`bool`和`string`类型，其它的15种内置基本类型都称为数值类型（整型、浮点数型和复数型）

Go中有两种内置类型别名（type alias）：

- `byte`是`uint8`的内置别名。 我们可以将`byte`和`uint8`看作是同一个类型
- `rune`是`int32`的内置别名。 我们可以将`rune`和`int32`看作是同一个类型

以`u`开头的整数类型称为无符号整数类型。 无符号整数类型的值都是非负的。 一个数值类型名称中的数字表示每个这个类型的值将在内存中占有多少二进制位（以后简称位）。二进制位常称为比特（bit）。 比如，一个`uint8`的值将占有8位。 我们称`uint8`类型的值的尺寸是8位。 因此，最大的`uint8`值是`255`（28-1）， 最大的`int8`值是`127`（27-1）， 最小的`int8`值是`-128`（-27）。

任一个类型的所有值的尺寸都是相同的，所以一个值的尺寸也常称为它的类型的尺寸。

更多的时候，我们使用字节（byte）做为值尺寸的度量单位。 一个字节相当于8个比特。所以`uint32`类型的尺寸为4，即每个`uint32`值占用4个字节。

`uintptr`、`int`以及`uint`类型的值的尺寸依赖于具体编译器实现。 通常地，在64位的架构上，`int`和`uint`类型的值是64位的；在32位的架构上，它们是32位的。 编译器必须保证`uintptr`类型的值的尺寸能够存下任意一个内存地址。

一个`complex64`复数值的实部和虚部都是`float32`类型的值。 一个`complex128`复数值的实部和虚部都是`float64`类型的值

在内存中，所有的浮点数都使用**IEEE-754格式**存储

一个布尔值表示一个真假。在内存中，一个布尔值只有两种可能的状态。 这两种状态使用两个预声明（或称为内置）的常量（`false`和`true`）来表示

从逻辑上说，一个字符串值表示一段文本。 在内存中，一个字符串存储为一个字节（byte）序列。 此字节序列体现了此字符串所表示的文本的UTF-8编码形式

尽管布尔和字符串类型分类各自只有一种内置类型， 我们可以声明定义更多自定义布尔和字符串类型。 所以，Go代码中可以出现很多布尔和字符串类型（数值类型也同样）。 下面是一个类型声明的例子。 在这些例子中，`type`是一个关键字

```go
// 一些类型定义声明
type status bool     // status和bool是两个不同的类型
type MyString string // MyString和string是两个不同的类型
type Id uint64       // Id和uint64是两个不同的类型
type real float32    // real和float32是两个不同的类型

// 一些类型别名声明
type boolean = bool // boolean和bool表示同一个类型
type Text = string  // Text和string表示同一个类型
type U8 = uint8     // U8、uint8和 byte表示同一个类型
type char = rune    // char、rune和int32表示同一个类型
```

我们将上面定义的`real`类型和内置类型`float32`都称为float32类型 （注意这里的第二个float32是一个泛指，而第一个高亮的float32是一个特指）。 同样地，`MyString`和`string`都被称为字符串（string）类型，`status`和`bool`都被称为布尔（bool）类型。

### 零值

每种类型都有一个零值。一个类型的零值可以看作是此类型的默认值。

- 一个布尔类型的零值表示真假中的假。
- 数值类型的零值都是零（但是不同类型的零在内存中占用的空间可能不同）。
- 一个字符串类型的零值是一个空字符串。

### 基本类型的字面量表示形式

一个值的字面形式称为一个字面量，它表示此值在代码中文字体现形式（和内存中的表现形式相对应）。一个值可能会有很多种字面量形式。

#### 布尔值的字面量形式

Go白皮书没有定义布尔类型值字面量形式。 我们可以将`false`和`true`这两个预声明的具名常量当作布尔类型的字面量形式。 但是，我们应该知道，从严格意义上说，它们不属于字面量。

布尔类型的零值可以使用预声明的`false`来表示。

#### 整数类型值的字面量形式

整数类型值有四种字面量形式：十进制形式（decimal）、八进制形式（octal）、十六进制形式（hex）和二进制形式（binary）。比如，下面的三个字面量均表示十进制的15：

```go
0xF // 十六进制表示（必须使用0x或者0X开头）
0XF

017 // 八进制表示（必须使用0、0o或者0O开头）
0o17
0O17

0b1111 // 二进制表示（必须使用0b或者0B开头）
0B1111

15  // 十进制表示（必须不能用0开头）
```

整数类型的零值的字面量一般使用`0`表示。 当然，`00`和`0x0`等也是合法的整数类型零值的字面量形式

#### 浮点数类型值的字面量形式

一个浮点数的完整十进制字面量形式可能包含一个十进制整数部分、一个小数点、一个十进制小数部分和一个以10为底数的整数指数部分。 整数指数部分由字母`e`或者`E`带一个十进制的整数字面量组成（`xEn`表示`x`乘以`10n`的意思，而`xE-n`表示`x`除以`10n`的意思）。 常常地，某些部分可以根据情况省略掉。一些例子：

```go
1.23
01.23 // == 1.23
.23
1.
// 一个e或者E随后的数值是指数值（底数为10）。
// 指数值必须为一个可以带符号的十进制整数字面量。
1.23e2  // == 123.0
123E2   // == 12300.0
123.E+2 // == 12300.0
1e-1    // == 0.1
.1e0    // == 0.1
0010e-2 // == 0.1
0e+5    // == 0.0
```

从Go 1.13开始，Go也支持另一种浮点数字面量形式：十六进制浮点数字面量。 在一个十六进制浮点数字面量中，

- 一个十六进制浮点数字面量必须以一个以2为底数的整数指数部分。 这样的一个整数指数部分由字母`p`或者`P`带一个十进制的整数字面量组成（`yPn`表示`y`乘以`2n`的意思，而`yP-n`表示`y`除以`2n`的意思）。
- 和整数的十六进制字面量一样，一个十六进制浮点数字面量也必须使用`0x`或者`0X`开头。 和整数的十六进制字面量不同的是，一个十六进制浮点数字面量可以包括一个小数点和一个十六进制小数部分。

一些合法的浮点数的十六进制字面量例子：

```go
0x1p-2     // == 1.0/4 = 0.25
0x2.p10    // == 2.0 * 1024 == 2048.0
0x1.Fp+0   // == 1+15.0/16 == 1.9375 F是十六进制数15
0X.8p1     // == 8.0/16 * 2 == 1.0
0X1FFFP-16 // == 0.1249847412109375
```

不合法的浮点数的十六进制字面量：

```go
0x.p1    // 整数部分表示必须包含至少一个数字
1p-2     // p指数形式只能出现在浮点数的十六进制字面量中
0x1.5e-2 // e和E不能出现在十六进制浮点数字面量的指数部分中
```

注意：下面这个表示是合法的，但是它不是浮点数的十六进制字面量。事实上，它是一个减法算术表达式。其中的`e`为是十进制中的`14`，`0x15e`为一个整数十六进制字面量，`-2`并不是此整数十六进制字面量的一部分

```go
0x15e-2 // == 0x15e - 2 (整数相减表达式)
```

浮点类型的零值的标准字面量形式为`0.0`。 当然其它很多形式也是合法的，比如`0.`、`.0`、`0e0`和`0x0p0`等

#### 虚部字面量形式
