# 《算法导论》CQUT课堂版

## 第一章 算法在计算中的作用

什么是算法？

* 算法：解决问题的方法
* 数据结构：存储信息的方法

在数学和计算机科学中，算法是如何解决一类问题的明确说明。

算法可以执行计算、数据处理和自动推理任务。

算法的定义：一种定义良好的计算过程，用于解决计算问题(将一些输入转化为期望的输出)。

算法描述了实现输入/输出关系的具体计算过程。

### 欧几里得算法(Euclid's algorithm)

计算两个非负整数p和q的最大公因子如下：

如果q为0，则答案为P.如果不是，那么q除以p，取余数r。答案就是q和r的最大公因子。

```python
def gcd(p, q):
    if q == 0:
        return p
    return gcd(q, p % q)
```

------



## 第二章 算法基础

### 插入排序(Insert sort)

> 对于少量元素的排序，是一个有效的算法

```pseudocode
INSERTION_SORT(A)
for j = 2 to A.length
	key = A[j]
	// Insert A[j] into the sorted sequence A[1..j-1]
	i = j - 1
	while i > 0 and A[i] > key
		A[i+1] = A[i]
		i = i - 1
	A[i+1] = key
```

我们通常使用伪代码来表示算法

伪代码中的一些约定：

```pseudocode
缩进表示块结构。例如，第1行开始的for循环体由第2~8行组成，第5行开始的 while
循环体包含第6~7行但不包含第8行。我们的缩进风格也适用于if-else语句。采用缩进来代替常规的块结构标志，如 begin和end语句，可以大大提高代码的清晰性。
while、for与repeat-until等循环结构以及if-else等条件结构与C、C+十、Java、Python和Pascal中的那些结构具有类似的解释。不像某些出现于C++、Java和Pascal中的情况，本书中在退出循环后，循环计数器保持其值。因此，紧接在一个for循环后，循环计数器的值就是第一个超出for循环界限的那个值。在证明插入排序的正确性时，我们使用了该性质。第1行的for循环头为for j=2 to A.length，所以，当该循环终止时，j=A.length+1(或者等价地，j=n十1，因为n=A.length)。当一个for循环每次迭代增加其循环计数器时，我们使用关键词to。当一个for循环每次迭代减少其循环计数器时，我们使用关键词downto。当循环计数器以大于1的一个量改变时，该改变量跟在可选关键词by之后。
符号“//”表示该行后面部分是个注释。
形如i=j=e的多重赋值将表达式e的值赋给变量i和j﹔它应被处理成等价于赋值j=e后跟着赋值i=j。
变量(如i、j和key)是局部于给定过程的。若无显式说明，我们不使用全局变量。
数组元素通过“数组名[下标]”这样的形式来访问。例如，A[i]表示数组A的第i个元素。记号“..”用于表示数组中值的一个范围，这样，A[1..j]表示A的一个子数组，它包含j个元素A[1]，A[2]，…，A[j]。
复合数据通常被组织成对象，对象又由属性组成。我们使用许多面向对象编程语言中创建的句法来访问特定的属性:对象名后跟一个点再跟属性名。例如，数组可以看成是一个对象，它具有属性length，表示数组包含多少元素，如A.length就表示数组A中的元素数目。
我们把表示一个数组或对象的变量看做指向表示数组或对象的数据的一个指针。对于某个对象x的所有属性f，赋值y=x导致y.f等于x.f。进一步，若现在置x.f=3，则赋值后不但x.f等于3，而且y.f也等于3。换句话说，在赋值y=x后，x和y指向相同的对象。
我们的属性记号可以“串联”。例如，假设属性f本身是指向某种类型的具有属性g的对象的一个指针。那么记号x.f.g被隐含地加括号成(x.f).g。换句话说，如果已经赋值y=x.f，那么x.f.g与y.g相同。
有时，一个指针根本不指向任何对象。这时，我们赋给它特殊值NIL。
我们按值把参数传递给过程:被调用过程接收其参数自身的副本。如果它对某个参数赋值，调用过程看不到这种改变。当对象被传递时，指向表示对象数据的指针被复制，而对象的属性却未被复制。例如，如果x是某个被调用过程的参数，在被调用过程中的赋值x=y对调用过程是不可见的。然而，赋值x.f=3却是可见的。类似地，数组通过指针来传递，结果指向数组的一个指针被传递，而不是整个数组，单个数组元素的改变对调用过程是可见的。
一个return语句立即将控制返回到调用过程的调用点。大多数return语句也将一个值传递回调用者。我们的伪代码与许多编程语言不同，因为我们允许在单一的return语句中返回多个值。
布尔运算符“and”和“or”都是短路的。也就是说，当求值表达式”x and y“时，首先求值x。如果x求值为FALSE，那么整个表达式不可能求值为TRUE，所以不再求值y。另外，如果x求值为TRUE，那么就必须求值y以确定整个表达式的值。类似地，对表达式“x or y”，仅当x求值为FALSE时，才求值表达式y。短路的运算符使我们能书写像“x≠NIL and x.f=y”这样的布尔表达式，而不必担心当x为NIL时我们试图求值x.f将会发生什么情况。
关键词error表示因为已被调用的过程情况不对而出现了一个错误。调用过程负责处理该错误，所以我们不用说明将采取什么行动。
```

### 正确性(Correctness)

如果对于每个输入实例，算法都以正确的输出停止，则称该算法是正确的。

我们说正确的算法解决了给定的计算问题。

### 循环不变式(Loop invariants)

定义：循环不变式是每次循环迭代结束时由变量和数据结构满足的条件和关系。

通常使用循环不变式来帮助我们理解为什么算法是正确的

关于循环不变式，我们必须证明三条性质:

* 初始化(Initialization): 循环的第一次迭代之前，它为真。

* 保持(Maintenance): 如果循环的某次迭代之前它为真，那么下次迭代之前它仍为真。

* 终止(Termination): 在循环终止时，不变式为我们提供一个有用的性质，该性质有助于证明算法是正确的。

**插入排序的正确性**

循环不变式：在 for 循环的每次迭代开始时，子数组 A[1..j-1] 由最初在 A[1..j-1] 中的元素组成，但按排序顺序排列

初始化：当j=2时，A[1..j-1]由单元素A[1]组成，一个元素那必然是已经排序好的

保持：内部 while 循环需要一个循环不变式。非正式地，它的工作原理是将 A[j-1]、A[j-2]、A[j-3] 等向右移动一个位置，直到找到 A[j] 的正确位置

终止：当 j = n+1，A[1..n] 由最初在 A[1..n] 中的元素组成但按排序顺序组成时结束

### 分析算法(Analysis algorithms)

最坏情况：（通常）
T(n) = 算法在任何大小为 n 的输入上的最长时间。
平均情况：（有时）
T(n) = 算法在大小为 n 的所有输入上的预期时间。
需要假设投入的统计分布
最佳情况：（虚假）
使用慢速算法作弊，该算法在某些输入上快速工作。

运行时间（Running time）T(n)：

取决于输入，（例如）已排序/反向排序
取决于输入大小，输入大小参数化
取决于想要的上限，一般而言。为用户提供保证

通常情况下，我们集中于只求最坏情况运行时间，因为：

最坏情况给出了一个上界

对于某些算法，最坏情况经常出现

平均情况往往与最坏情况一样差

### 增长量级

我们真正感兴趣的是运行时间的增长率或增长量级

对于插入排序来说，最坏情况T(n) = an^2^+bn+c

我们只考虑公式中最重要的一项：n^2^

我们就说，插入排序具有最坏情况运行时间Θ(n^2^)

如果一个算法的最坏情况运行时间具有比另一个算法更低的增长量级，那么我们通常认为前者比后者更有效

------



## 第三章 函数增长

### 渐进记号

#### O记号

给出一个渐进上界

定义：O(g(n)) = {f(n): 存在正常量c和n~0~，使得对所有n ≥ n~0~，有0 ≤ f(n) ≤ cg(n)}

例子：

证明2n^2^ = O(n^3^)

也就是需要找到c和n~0~，使得 0 ≤ 2n^2^ ≤ cn^3^，对于所有的n≥n~0~

选择c = 2，n~0~ = 1

就有 2n^2^ ≤ 2n^3^，对于所有n ≥ 1

或者c = 1，n~0~ = 2

就有 2n^2^ ≤ n^3^，对于所有n ≥ 2

#### Ω记号

给出一个渐进下界

定义：Ω(g(n)) = {f(n): 存在正常量c和n~0~，使得对所有n ≥ n~0~，有0 ≤ cg(n) ≤ f(n)}

例子：

证明2n^3^ = Ω(n^2^)

也就是需要找到c和n~0~，使得 0 ≤ cn^2^ ≤ 2n^3^，对于所有的n≥n~0~

选择c = 1，n~0~ = 1

就有 n^2^ ≤ 2n^3^，对于所有n ≥ 1

#### Θ记号

给出渐近紧确界

定义：Θ(g(n)) = {f(n): 存在正常量c~1~，c~2~和n~0~，使得对所有n ≥ n~0~，有0 ≤ c~1~g(n) ≤ f(n) ≤ c~2~g(n)}

例子：

证明2n^2^ + n = O(n^2^)

也就是需要找到c~1~，c~2~和n~0~，使得 0 ≤ c~1~n^2^ ≤ 2n^2^ + n ≤ c~2~n^2^，对于所有的n ≥ n~0~

那么就有 c~1~ ≤ 2 + 1/n ≤ c~2~，对于所有的n ≥ n~0~

选择c~1~ = 2，c~2~ = 3，n~0~ = 1

就有2n^2^ ≤ 2n^2^ + n ≤ 3n^2^，对于所有的n ≥ 1

#### o记号

给出一个非渐近紧确上界

也就是O记号的没有等于的版本

#### ω记号

给出一个非渐近紧确下界

也就是Ω记号的没有等于的版本

------



## 第四章 分治策略

许多有用的算法在结构上是递归的;为了解决一个给定的问题，算法一次或多次递归地调用其自身以解决紧密相关的若干子问题。这些算法典型地遵循分治法的思想:将原问题分解为几个规模较小但类似于原问题的子问题，递归地求解这些子问题，然后再合并这些子问题的解来建立原问题的解。

分治模式在每层递归时都有三个步骤:

分解（Divide）原问题为若干子问题，这些子问题是原问题的规模较小的实例。

解决（Conquer）这些子问题，递归地求解各子问题。然而，若子问题的规模足够小，则直接求解。

合并（Combine）这些子问题的解成原问题的解。

### 归并排序

分解: 分解待排序的n个元素的序列成各具n/2个元素的两个子序列。

解决: 使用归并排序递归地排序两个子序列。

合并: 合并两个已排序的子序列以产生已排序的答案。

关键步骤是合并

给出合并定义，A为一个数组，p，q，r是数组下标，满足p ≤ q＜r。且假设子数组A[p..q]和A[q+1..r]都已排好序。它合并这两个子数组形成单一的已排好序的子数组并代替当前的子数组A[p..r]。

```pseudocode
MERGE(A, p, q, r)
n1 = q - p + 1
n2 = r - q
let L[1..n1+1] and R[1..n2+1] be new arrays
for i = 1 to n1
	L[i] = A[p + i - 1]
for j = 1 to n2
	R[j] = A[q + j]
L[n1+1] = ∞
R[n2+1] = ∞
i = 1
j = 1
for k = p to r
	if L[i] ≤ R[j]
		A[k] = L[i]
		i = i + 1
	else A[k] = R[j]
		j = j + 1
```

合并步骤需要Θ(n)的时间，n = r - p + 1，是待合并元素的总数

再将以上的合并作为归并排序的子程序调用，给出归并排序的定义

```pseudocode
MERGE-SORT(A, p, r)
if p < r
	q = ⌊(p+r)/2⌋
	MERGE-SORT(A, p, q)
	MERGE-SORT(A, q+1, r)
	MERGE(A, p, q, r)
```

