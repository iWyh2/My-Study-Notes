# 《大话数据结构》

# 1. 线性表

【特性】

* 零个或多个数据元素的有限序列（有顺序）
* 线性表元素的个数n为线性表的长度



【定义】

```apl
ADT List(线性表)
Data
	线性表的数据对象集合为{a1,a2,a3,...,an}，每个元素的类型均为DataType。其中，除第一个元素a1外，每一个元素有且只有一个直接前驱元素，除了最后一个元素an外，每一个元素有且只有一个直接后继元素。数据元素之间的关系是一对一的关系
Operation
	InitList(*L) := 初始化操作，建立一个空的线性表L
	ListEmpty(L) := 若线性表为空，返回true，否则返回false
	ClearList(*L) := 将线性表清空
	GetElem(L,i,*e) := 将线性表L中的第i个位置元素值返回给e
	LocateElem(L,e) := 在线性表L中查找与给定值e相等的元素，如果查找成功，返回该元素在表中序号表示成功；否则，返回0表示失败
	ListInsert(*L,i,e) := 在线性表L中的第i个位置插入新元素e
	ListDelete(*L,i,*e) := 删除线性表L中第i个位置元素，并用e返回其值
	ListLength(L) := 返回线性表L的元素个数
endADT
```

## 1.1 线性表的线性存储结构

【特性】

* 用连续地址的存储单元存储线性表元素
* 一维数组即可实现

* 地址计算方法（LOC函数）：LOC(ai) = LOC(a1) + (i - 1) * c（每个元素占据c个存储单元）
* 存取时间性能为O(1)，为随机存取结构

* 线性表长度要小于数组长度



【性能优缺点】

优点：

* 插入到最后一个元素：O(1)
* 删除最后一个元素：O(1)
* 读取任意位置元素：O(1)
* 快速存取

缺点：

* 插入到第一个位置：O(n)
* 删除第一个位置元素：O(n)
* 插入第i个和删除第i个平均为：O(n)
* 插入和删除需要移动大量元素

## 1.2 线性表的链式存储结构

### 1.2.1 单链表

【特性】

* 地址并不连续的存储单元存储元素
* 元素由节点Node存储，节点由指针域和数据域组成
* 指针域只指向后继



【性能优缺点】

时间性能

优点：

* 插入和删除：O(1)

缺点：

* 查找：O(n)

空间性能：单链表无需预分配存储空间，元素个数不受限制



【单链表与顺序存储】

频繁查找，很少插入删除：顺序存储

频繁插入删除：单链表

元素变化较大且不知数量：单链表

提前知道线性表长度：顺序存储

### 1.2.2 静态链表

【特性】

* 用数组替代指针来描述单链表
* 数组每个元素都有两个数据域：data 和 cur
* data是存放数据用。cur为存放该元素的后继在数组中的下标位置，也叫游标
* 数组第一个和最后一个位置不存数据，作为特殊元素
* 未被使用的数组元素为备用链表
* 数组第一个元素，cur存放备用链表的第一个结点的下标位置，备用链表的头指针
* 数组的最后一个元素，cur存放第一个有数值的元素的下标位置，相当于头结点
* 线性表的最后一个有值元素的下一位置为空，所以最后一个有值元素的cur存放0



【性能优缺点】

优点

* 插入删除：O(1)

缺点

* 平均查找：O(n)（单链表的特性）

* 失去了顺序存储结构的随机存取

### 1.2.3 循环链表

【特性】

* 单链表终结点指针指向头结点，成为单循环链表
* 从一个节点出发访问到链表的全部节点
* 判断遍历的结束条件为：下一节点不为头结点



【性能优缺点】

优点

* 查找头尾结点：O(1)

### 1.2.4 双向链表

【特性】

* 每个节点都有前驱和后继，两个指针域
* 许多操作与单链表相同，只涉及一个方向
* 也可以是循环链表



【性能优缺点】

优点

* 插入和删除：O(1)
* 查找头尾结点：O(1)

缺点：

* 平均查找：O(n)

------



# 2. 栈

【特性】

* 仅在表尾进行插入和删除操作的**线性表**
* 后进先出（Last In First Out）
* 允许插入和删除的一端为栈顶（top），另一端为栈底（bottom）
* 栈顶就是表尾
* 最先进入的只能在栈底



【定义】

```apl
ADT Stack(栈)
Data
	同线性表。元素具有相同类型，相邻元素具有前驱和后继关系
Operation
	InitStack(*S) := 初始化操作，建立一个空栈S
	DestroyStack(*S) := 若栈存在就销毁
	ClearStack(*S) := 将栈清空
	StackEmpty(S) := 若栈为空，返回true，否则返回false
	GetTop(S,*e) := 若栈存在且非空，用e返回S的栈顶元素
	Push(*S,e) := 若栈S存在，插入新元素e到栈S中并成为栈顶元素
	Pop(*S,*e) := 删除栈S中栈顶元素，并用e返回其值
	StackLength(S) := 返回栈S的元素个数
endADT
```

## 2.1 栈的顺序存储结构

【特性】

* 为线性表的顺序存储的简化
* 下标为0的一端作为栈底
* top指示栈顶元素在数组中的位置
* 空栈为：top = -1



【性能优缺点】

优点

* 出栈入栈均为：O(1)

缺点

* 顺序栈需要事先确定一个固定的长度，会有浪费内存空间的情况

## 2.2 栈的链式存储结构

【特性】

* 栈顶放在单链表的头部
* 不需要头结点
* 不存在栈满的情况
* 空栈：top = NULL



【性能优缺点】

优点

* 出栈入栈均为：O(1)

缺点

* 链栈每个元素有指针域，有额外的内存开销



【对比】

* 元素变化不可预料，有时很小，有时很大，用链栈
* 变化在可控范围内用顺序栈



【栈的应用】

* 递归（斐波那契数列）
* 四则远算表达式（后缀表达式）

------



# 3. 队列

【特性】

* 只允许在一端进行插入操作，在另一端进行删除操作的**线性表**
* 先进先出（First In First Out）
* 插入的一端为队尾，删除的一端为队头



【定义】

```apl
ADT Queue(队列)
Data
	同线性表。元素具有相同类型，相邻元素具有前驱和后继关系
Operation
	InitQueue(*Q) := 初始化操作，建立一个空队列Q
	DestroyQueue(*Q) := 若队列存在就销毁
	ClearQueue(*Q) := 将队列清空
	QueueEmpty(Q) := 若队列为空，返回true，否则返回false
	GetHead(Q,*e) := 若队列存在且非空，用e返回队列Q的队头元素
	EnQueue(*Q,e) := 若队列存在，插入新元素e到队列Q中并成为队尾元素
	DeQueue(*Q,*e) := 删除队列中队头元素，并用e返回其值
	QueueLength(Q) := 返回队列的元素个数
endADT
```

## 3.1 队列的顺序存储结构

【特性】

* 入队列操作不需要移动元素，在队尾追加一个元素
* 出队列操作需要所有的元素向前移动
* front指针指向队头元素，rear指针指向队尾元素的下一个位置
* 空队列：front == rear



【性能优缺点】

优点

* 入列：O(1)

缺点

* 出列：O(n)
* 会有假溢出现象，浪费内存

### 3.1.1 循环队列

【特性】

* 头尾相接
* 空队列：front == rear
* 满队列：(rear + 1) % QueueSize == front（保留一个元素位置为队列满）
* 队列长度：（rear - front + QueueSize ）% QueueSize
* 数组可能会溢出



【性能优缺点】

优点

* 入列：O(1)
* 出队：O(1)

缺点

* 必须有固定的长度，会有内存浪费

## 3.2 队列的链式存储结构

【特性】

* 只能尾进头出
* 头指针指向头结点
* 空队列：front和rear都指向头结点
* 入链队列，无需判断队满
* 出链队列，头结点的后继结点出队



【性能优缺点】

优点

* 入列：O(1)
* 出队：O(1)

缺点

* 每次申请和释放结点会有时间开销
* 指针域会有内存上的额外开销



【链队列和循环队列对比】

* 确定队列最大长度用循环队列
* 无法估计队列长度用链队列

------



# 4. 串



------



# 5. 树

【特性】

* 一对多
* 只有一个根结点
* 子树个数没有限制，且互不相交
* 结点拥有的子树数称为**结点的度**（Degree）
* 树内各结点的度的最大值为**树的度**
* 度为0的结点为**叶结点**（也叫终端节点），度不为0的结点也叫分支结点
* 结点关系：孩子（Child），双亲（Parent），兄弟（Sibling）
* **结点的层次**（Level）：从根结点开始的层数，根结点在第一层；同一层的结点为堂兄弟
* 树中结点的最大层次称为**树的深度**/**高度**（Depth）
* 有序树：各子树从左至右有次序，不能互换；反之为无序数
* 森林：互不相交的树的集合；每个结点的子树的集合就是森林



【定义】

```apl
ADT Tree(树)
Data
	树由一个根结点和若干子树构成。树中结点具有相同数据类型及层次关系
Operation
	InitTree(*T) := 构造空树T
	DestroyTree(*T) := 销毁树T
	CreateTree(*T,definition) := 按definition给出的树的定义构造树
	ClearTree(*T) := 将树T清空
	TreeEmpty(T) := 若树T为空，返回true，否则返回false
	TreeDepth(T) := 返回树的深度
	Root(T) := 返回树的根结点
	Value(T,cur_e) := cur_e是树的一个结点，返回此结点的值
	Assign(T,cur_e,value) := 给树的结点cur_e赋值为value
	Parent(T,cur_e) := 若cur_e是树的非根结点，则返回双亲结点，否则返回空
	LeftChild(T,cur_e) := 若cur_e是树的非叶结点，则返回cur_e的最左孩子，否则返回空
	RightSibling(T,cur_e) := 若cur_e有右兄弟，则返回cur_e的右兄弟，否则返回空
	InsertChild(*T,*p,i,c) := p指向树中某个结点，i为所指结点p的度加1，c为非空树与T不相交，操作为插入c为树T中p指向结点的第i棵子树
	DeleteChild(*T,*p,i) := p指向树中某个结点，i为所指结点p的度，操作为删除T中p所指向的结点的第i棵子树
endADT
```



【树的存储结构】

1. 双亲表示法

   除了根结点外，其余每个结点不一定有孩子，但一定有且仅有一个双亲

   **以连续空间存储**树的结点

   ①树的结点包含：data数据域，parent指针域（指向双亲）

   * 约定根结点的位置域为-1
   * 无法得知孩子结点是什么，需要遍历完才得知

   ②树的结点包含：data数据域，parent指针域，firstchild指针域（指向最左孩子）

   * 约定没有孩子则为-1
   * 无法得知兄弟节点

   ③树的结点包含：data数据域，parent指针域，firstchild指针域，rightsib指针域（指向右兄弟）

   * 约定没有右兄弟为-1
   * 复杂

2. 孩子表示法

   树中每个结点可能有多棵子树

   以**多重链表**表示

   ①树的结点有多个指针域，指针域个数为树的度：data数据域，child1，child2...各指针域

   * 各结点度相差很大时会浪费空间

   ②树的结点有多个指针域，指针域个数为该结点的度，额外增添一个度域：data数据域，degree度域，child1，child2...各指针域

   * 各结点结构不同，要额外维护度域的值，运算和维护耗费大

   以**数组+链表**表示

   将每个结点的孩子以单链表存储，各链表头指针又组成一个线性表

   孩子链表的孩子结点：child数据域，next指针域（指向下一个孩子）

   表头数组的表头结点：data数据域（结点的数据），firstchild指针域（存储结点的孩子链表的头指针）

   要得知结点的双亲，需要在表头数组中额外添加一个parent指针域（存储双亲下标，根结点为-1）

3. 孩子兄弟表示法

   寻找结点的第一个孩子和右兄弟

   以**链表**表示

   结点包含：data数据域，firstchild指针域，rightsib指针域

   * 方便查找某结点的某个孩子
   * 可以额外增添parent指针域查询存储双亲
   * **将一棵复杂的树变为了一棵二叉树**



【树与森林的遍历】

* 树的遍历：
  * 先根遍历
  * 后根遍历

* 森林遍历：
  * 前序遍历
  * 后序遍历

## 5.1 二叉树

Binary Tree

【特点】

* 每个结点最多两棵子树（二叉树不存在度大于2的结点）
* 左子树和右子树有次序，无法颠倒
* 即使树的某结点只有一颗子树，也要区分是左子树还是右子树（也许是同一棵树，但是是不同的二叉树）



【二叉树的五种形态】

* 空树
* 只有一个根结点
* 根结点只有左树
* 根结点只有右树
* 根结点有左右子树



【二叉树的特殊形态】

* 斜树
  * 所有结点只有左子树或右子树，分别叫左斜树和右斜树
  * 每一层只有一个结点
  * 结点个数 = 树的深度
  * **线性表为特殊的树结构**，为斜树

* 满二叉树
  * 所有分支结点都有左右子树
  * 所有叶子结点都在同一层
  * 最后一层必定是叶子结点
  * 非叶子结点的度一定为2
  * 同样深度的二叉树，满二叉树结点个数最多，叶子结点最多

* 完全二叉树
  * 所有结点顺序位置（从1到n按层序编号）与相同深度的满二叉树的结点位置一一对应
  * 满二叉树一定是完全二叉树；完全二叉树不一定是满二叉树
  * 叶子结点一定只能在最下两层位置
  * 最后一层叶子结点靠左连续集中
  * 倒数第二层如果有叶子节点，一定靠右连续集中
  * 结点度为1，只能有左孩子
  * 同样结点数的二叉树，完全二叉树深度最小



【性质】

1. 二叉树的第i层至多有$2^{i-1}$个结点（i $\geq$ 1）
2. 深度为k的二叉树至多(满二叉树)有$2^k - 1$个结点（k $\geq$ 1）
3. 任意二叉树T，终端结点数(叶子结点数)为$n_0$，度为2的结点数为$n_2$，则$n_0$ = $n_2$ + 1
   * 度为1的结点数为$n_1$，二叉树T的总结点数$n = n_0 + n_1 + n_2$
   * 分支线总数为结点总数减一（n - 1），等于$n_1 + 2n_2$
4. n个结点的完全二叉树的深度为$⌊log_2n⌋+1$（⌊ x ⌋为不大于x的最大整数）
5. 对一棵n个结点的完全二叉树（深度为$⌊log_2n⌋+1$）的结点按层序编号，从第一层到第$⌊log_2n⌋+1$层，每层从左往右，对任意一结点i（$1\leq i\leq n$）：
   * i = 1，则结点i为二叉树的根结点，无双亲；i > 1，则其双亲结点为$⌊i/2⌋$
   * 2i > n，则结点i无左孩子，为叶子结点；否则左孩子为结点2i
   * 2i > n - 1，则结点i无右孩子；否则右孩子为结点2i+1



【二叉树的存储结构】

顺序存储结构：

* 用一维数组存储二叉树的结点，数组下标要体现结点间的关系
* **一般只用于存储完全二叉树**

链式存储结构：

* 二叉树每个结点最多两个孩子，设计一个结点包含：一个数据域data，两个指针域lchild和rchild
* 称之为**二叉链表**



【二叉树的的遍历】

指从根结点出发，按照某种次序依次访问二叉树中所有结点一次

遍历方法：

* 前序遍历（根 -> 左 -> 右）
* 中序遍历（左 -> 根 -> 右）
* 后序遍历（左 -> 右 -> 根）
* 层序遍历（每层从左往右）

**把树中结点变为线性序列方便计算机处理**

推导遍历结果：

* 前序遍历为先打印结点数据再递归左右
* 中序遍历和后序遍历为先递归到最左再打印接着递归剩下的

二叉树遍历性质：

* 已知前序遍历序列和**中序遍历序列**，可以唯一确定一棵二叉树
* 已知后序遍历序列和**中序遍历序列**，可以唯一确定一棵二叉树



【二叉树的建立】

输入一个遍历序列以建立一棵二叉树

将已知二叉树的每个结点扩展，使每个结点可以确认是否有左右孩子，没有就以"#"代替

假设获得前序遍历序列为AB#D##C##，根据这个遍历序列建立二叉树

**利用递归，在遍历二叉树时，生成结点并且给结点做赋值操作**



【树，森林，二叉树的相互转化】

* 树转二叉树
  1. 加线；在所有兄弟结点之间加一条线
  2. 去线；对树中每个结点，只保留它与第一个孩子结点的连线，删除它与其他孩子结点之间的连线
  3. 层次调整；以树的根结点为轴心，将整棵树顺时针旋转一定角度，使结构分明；第一个孩子结点为二叉树结点的左孩子，兄弟结点为右孩子
* 森林转二叉树
  1. 先将每棵树转为二叉树
  2. 第一棵二叉树不动，从第二棵二叉树开始，依次把后一棵二叉树的根结点作为前一棵二叉树的根结点的右孩子，用线连接；所有二叉树连接起来后就得到了最终的完整二叉树
* 二叉树转树
  1. 加线；若某结点的左孩子结点存在，则将这个左孩子结点的所有右孩子结点都作为当前结点的孩子，并连线
  2. 去线；删除原二叉树中所有结点与其右孩子结点的连线
  3. 层次调整；使结构分明
* 二叉树转森林
  1. 从根结点开始，若右孩子存在，则把与右孩子的连线删除；在查看分离后的右孩子二叉树的根结点，若右孩子存在，则继续删除相同连线...；直到所有右孩子连线都被删除，得到分离后的一棵棵二叉树
  2. 再将每棵二叉树转为树

判断一棵二叉树能转为一棵树还是森林，只要看这棵二叉树的根结点有没有右孩子，有就是森林，没有就是树

## 5.2 线索二叉树

Threaded Binary Tree

* 普通二叉树要想知道它的前驱和后继，需要在遍历之后才能知晓
* 普通二叉树的二叉链表存储形式，有n个结点的二叉链表，一共2n个指针域，n个结点有n-1条分支线，产生$2n-(n-1)=n+1$个空指针域

考虑在建立二叉树时就记住结点的前驱和后继，且用空指针域存放前驱和后继的地址

【定义】

**指向前驱和后继的指针为线索，有线索的二叉链表为线索链表，树即为线索二叉树**



【特点】

* 线索二叉树就是把二叉树**转为了一个双向链表**
* 为插入删除带来了便利
* 没有左孩子，使其指向该结点的前驱
* 没有右孩子，使其指向该结点的后继
* 线索二叉树的结点多了分区标志值ltag和rtag，判断是指向前驱后继（1）还是孩子结点（0）
* 对二叉树以某种次序遍历使其成为线索二叉树的过程称为线索化；线索化的实质是将二叉链表的空指针改为指向前驱或后继的线索



【优缺点】

* 遍历线索二叉树的时间复杂度为：O(n)

## 5.3 赫夫曼树

【定义】

* 从树的一个结点到另一个结点之间的分支构成两个结点之间的路径，路径上的分支数目称为路径长度
* 树的路径长度为从根结点到每一个结点的路径长度之和
* 考虑上带权，结点的带权路径长度WPL为结点到根的路径长度与权值的乘积
* 树的带权路径长度WPL为所有结点的WPL之和
* WPL最小的树，为赫夫曼树，也叫最优二叉树（本质还是二叉树）



【构造赫夫曼树的赫夫曼算法】

1. 根据给定的n个权值$\{w_1,w_2,w_3,...,w_n\}$构成n棵二叉树的集合F=$\{T_1,T_2,...,T_n\}$，其中每棵二叉树$T_i$中只有一个带权的为$w_i$的根结点，其左右子树均为空
2. 在F中选取两棵根结点的权值最小的树作为左右字数构造一棵新的二叉树，且置新的二叉树的根结点的权值为其左右子树根结点的权值之和
3. 在F中删除选取的这两棵树，同时将新得到的二叉树加入F
4. 重复步骤2和3，直到F中只含有一棵树为止。此时的这棵树就是赫夫曼树



【作用】

* 压缩
* 解决远距离通信的数据传输的最优化问题



【衍生】

赫夫曼编码：

一般地，设需要编码的字符集为{$d_1,d_2,...,d_n$}，各个字符在电文中出现的次数或频率集合为{$w_1,w_2,...,w_n$}，以$d_1,d_2,...,d_n$作为叶子结点，以$w_1,w_2,...,w_n$作为相应的叶子结点的权值来构造赫夫曼树。规定赫夫曼树的左分支代表0，右分支代表1，则从赫夫曼树的根结点到叶子结点所经过的路径分支组成的0和1的序列就是该结点对应字符的编码，也就是赫夫曼编码

## 5.4 二叉排序树



## 5.5 平衡二叉树

## 5.6 2-3树

## 5.7 2-3-4树

## 5.8 B树

## 5.9 B+树

------

# 6. 堆

------



# 7. 哈希表

------



# 8. 图



------

